/**
 * 🚫 Single Process Example without Cluster
 *
 * This version runs a basic Express server on a single thread.
 * All requests are handled by one process, so CPU-bound tasks
 * will block all other incoming requests until complete.
 *
 * ❗ This setup is **not suitable** for high-load production use,
 * especially if there are blocking operations.
 */

const express = require("express");
const os = require("os");
const process = require("process");

const app = express();
const PORT = 3000;

console.log(`🚫 Running in single process mode`);
console.log(`🧠 PID: ${process.pid}`);
console.log(`💻 Available CPUs (not used): ${os.cpus().length}`);

// 🧪 Simulate a CPU-bound task like generating a large report
app.get("/generate-report", (req, res) => {
  console.log(`📄 [/generate-report] Request received by PID ${process.pid}`);
  let total = 0;
  for (let i = 0; i < 1e5; i++) {
    for (let j = 0; j < 1e4; j++) {
      total += Math.sin(i) * Math.tan(j) * 0.0000001;
    }
  }
  res.send(`📄 Report generated by PID ${process.pid}: ${total.toFixed(2)}`);
  console.log(`📄 Report generated by PID ${process.pid}: ${total.toFixed(2)}`);
});

app.listen(PORT, () => {
  console.log(`🚀 Server listening at http://localhost:${PORT}`);
});

/**
 * 🔁 Flow:
 * 1. A single process starts and listens on a port.
 * 2. When a request is made to /generate-report,
 *    the process executes a heavy CPU task.
 * 3. While this task runs, no other requests can be served.
 * 4. After the task completes, the response is returned.
 *
 * ❗ Consequence: During heavy computation, all other
 * requests are blocked, making the app unresponsive.
 */
